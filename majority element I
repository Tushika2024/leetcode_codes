brute force-
for(i=0;i<n;i++){
count=0;
  for(j=0;j<n;j++){
    if(nums[i]==nums[j]){
    count++;
  }
  if(count>n/2){
    cout<<arr[i];
  }
}

optimal - using unordered map

op-II
int majorityElement(vector<int>& nums) {
       sort(nums.begin(),nums.end());
       int nel=nums[0];
       int c=1;
       for(int i=1;i<nums.size();i++){
            if(nums[i]==nel){                     // majority  element may or not exist
                c++;
            }else{
                if(c>(nums.size()/2)){
                    return nel;
                }
                nel=nums[i];
                c=1;
            }
       }
       if(c>(nums.size()/2)){
        return nel;
       }
       return -1;
    }

    or

  int majorityElement(vector<int>& nums) {
       sort(nums.begin(),nums.end());       // if  majority element always exists
      return nums[nums.size()/2];
    }



    op=III
    moores voting algo
    int majorityElement(vector<int>& nums) {
       int count=0;
       int el;
       for(int i=0;i<nums.size();i++){
            if(count==0){
                el=nums[i];
                count=1;
            }else{
                if(nums[i]==el){
                    count++;
                }else{
                    count--;
                }
            }
       }
       int count1=0;                                   return el; // if majority element always exist
       for(int i=0;i<nums.size();i++){  
            if(nums[i]==el){
                 count1++;
            }
        }
        if(count1>(nums.size()/2)){
             return el;
        }
        return -1;
      
    }
