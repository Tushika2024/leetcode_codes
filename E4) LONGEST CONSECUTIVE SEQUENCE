BRUTE-  TC=O(N2)  sc=o(1)
bool ls(vector<int>&nums,int el){
        for(int i=0;i<nums.size();i++){
            if(nums[i]==el) return true;
        }
        return false;
    }
    int longestConsecutive(vector<int>& nums) {
        int maxc=INT_MIN;
        for(int i=0;i<nums.size();i++){
            int c=1;
            int el=nums[i];
            while(ls(nums,el+1)){
                el+=1;
                c++;
            }
            maxc=max(maxc,c);
        }
        return maxc;
    }
BETTER- TC=O(NLOGN+N)  SC=O(1)
int longestConsecutive(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int c=1;
        int maxc=INT_MIN;
        for(int i=1;i<nums.size();i++){
            if(nums[i]==nums[i-1]) continue;
            else if(nums[i]==(nums[i-1]+1)) c++;
            else{
                maxc=max(maxc,c);
                c=1;
            }
        }
        maxc=max(maxc,c);
        return maxc;
    }
OPTIMAL- TC=O(N)+O(2N)  SC=O(N)
int longestConsecutive(vector<int>& nums) {
       unordered_set<int>st;
       int maxc=INT_MIN;
       if(nums.size()==0) return 0;
       for(int i=0;i<nums.size();i++){
        st.insert(nums[i]);
       }
       int c=0;
       for(auto it:st){
            if(st.find(it-1)!=st.end()) continue;
            else{
                int c=1;
                int el=it+1;
                while(st.find(el)!=st.end()){
                    c++;
                    el+=1;
                }
                maxc=max(maxc,c); 
            }
       }
       return maxc;
    }
