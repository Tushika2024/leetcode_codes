BFA-
outer loop for(i=minday to maxday)

 OPI-
 int noOfbouquets(vector<int>bloomDay,int m,int k,int day){
        int c=0;
        int mdp=m;
        for(int i=0;i<bloomDay.size();i++){
                if(bloomDay[i]<=day){
                    c++;
                    if(c==k){
                        mdp--;
                        c=0;
                    }
                }else{
                    c=0;
                }
        }
        return mdp;
    }
    int minDays(vector<int>& bloomDay, int m, int k) {
        int maxel=INT_MIN;
        int minel=INT_MAX;
        for(int i=0;i<bloomDay.size();i++){
            minel=min(minel,bloomDay[i]);
            maxel=max(maxel,bloomDay[i]);
        }
        // int ans=INT_MAX;
        int start=minel;
        int end=maxel;
        while(start<=end){
            int mid=start+((end-start)/2);
            int mdpans=noOfbouquets(bloomDay,m,k,mid);
            if(mdpans>0){
                start=mid+1;
            }else{
                // ans=min(ans,mid);
                end=mid-1;
            }
        }
        return( (start>maxel) ? -1:start);
    }

    OP STRUVER-
     bool possible(vector<int>bloomDay,int m,int k,int day){
        int c=0;
        int mdp=0;
        for(int i=0;i<bloomDay.size();i++){
                if(bloomDay[i]<=day){
                    c++;
                }else{
                    mdp+=c/k;
                    c=0;
                }
        }
        mdp+=c/k;
        return mdp>=m;
    }
    int minDays(vector<int>& bloomDay, int m, int k) {
        long long val=m*1LL*k*1LL;
        if(bloomDay.size()<val){
            return -1;
        }
        int maxel=INT_MIN;
        int minel=INT_MAX;
        for(int i=0;i<bloomDay.size();i++){
            minel=min(minel,bloomDay[i]);
            maxel=max(maxel,bloomDay[i]);
        }
        // int ans=INT_MAX;
        int start=minel;
        int end=maxel;
        while(start<=end){
            int mid=start+((end-start)/2);
            if(possible(bloomDay,m,k,mid)){
                 // ans=min(ans,mid);
                end=mid-1;
            }else{
                start=mid+1;
            }
        }
        return start;
    }
};
