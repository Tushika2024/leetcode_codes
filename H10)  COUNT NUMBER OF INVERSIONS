BRUTE-                                                  TC=O(N2)
  int inversionCount(vector<int> &arr) {
        // Code Here
        int cnt=0;
        for(int i=0;i<arr.size();i++){
            for(int j=i+1;j<arr.size();j++){
                if(arr[i]>arr[j]) cnt++;
            }
        }
        return cnt;
    }


OPTIMAL-                                        TC=(NLOGN)  SC=O(N)
  int merge(vector<int>&arr,int st,int mid,int end){
        int count=0;
        int i=st;
        int j=mid+1;
        vector<int>ans;
        while(i<=mid && j<=end){
            if(arr[i]>arr[j]){
                count+=(mid-i+1);
                ans.push_back(arr[j]);
                j++;
            }else{
                ans.push_back(arr[i]);
                i++;
            }
        }
        while(i<=mid){
            ans.push_back(arr[i]);
            i++;
        }
        while(j<=end){
            ans.push_back(arr[j]);
            j++;
        }
        for(int k=st;k<=end;k++){
            arr[k]=ans[k-st];
        }
        return count;
    }
    int mergeSort(vector<int>&arr,int st,int end){
        int count=0;
        if(st>=end) return 0;
        int mid=st+((end-st)/2);
        count+=mergeSort(arr,st,mid);
        count+=mergeSort(arr,mid+1,end);
        count+=merge(arr,st,mid,end);
        return count;
    }
    int inversionCount(vector<int> &arr) {
        // Code Here
        return mergeSort(arr,0,arr.size()-1);
    }
